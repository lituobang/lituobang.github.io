<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Manual Predatory CA: Institutional Evolution</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { margin: 0; background: #0a0a0c; color: #d1d1d1; font-family: 'Consolas', monospace; overflow: hidden; }
        #control-panel { 
            position: absolute; left: 20px; top: 20px; width: 280px; 
            background: rgba(15, 15, 20, 0.95); padding: 20px; 
            border: 1px solid #444; border-radius: 4px; z-index: 1000;
        }
        .stat { font-size: 13px; margin: 8px 0; color: #888; border-bottom: 1px solid #222; padding-bottom: 4px; }
        .val { float: right; color: #f44336; font-weight: bold; }
        #phase-title { font-size: 18px; color: #4caf50; margin-bottom: 15px; font-weight: bold; }
        
        .btn-group { display: flex; gap: 10px; margin-top: 15px; }
        button { 
            flex: 1; padding: 12px; border: none; border-radius: 4px; 
            cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        #step-btn { background: #4caf50; color: white; }
        #step-btn:hover { background: #66bb6a; }
        #reset-btn { background: #444; color: #ccc; }
        
        canvas { display: block; image-rendering: pixelated; }
        .legend { font-size: 11px; color: #666; margin-top: 15px; line-height: 1.6; }
    </style>
</head>
<body>

<div id="control-panel">
    <div id="phase-title">Manual Evolution Mode</div>
    
    <div class="stat">Current Step: <span class="val" id="v-step">0</span></div>
    <div class="stat">Predator/Producer Ratio: <span class="val" id="v-ratio">0%</span></div>
    <div class="stat">System Complexity (H): <span class="val" id="v-h">Chaos</span></div>
    
    <div class="btn-group">
        <button id="step-btn" onclick="manualStep()">Step Forward</button>
        <button id="reset-btn" onclick="resetSim()">Reset</button>
    </div>

    <div class="legend">
        <b style="color:#4caf50">Green:</b> Producers (Resources)<br>
        <b style="color:#f44336">Red:</b> Predators (Extraction)<br>
        <b style="color:#888">Rule:</b> Grouped Predators (Clusters) have exponentially higher extraction power.
    </div>
</div>

<canvas id="caCanvas"></canvas>

<script>
    const canvas = document.getElementById('caCanvas');
    const ctx = canvas.getContext('2d');
    const width = window.innerWidth, height = window.innerHeight;
    canvas.width = width; canvas.height = height;

    const cellSize = 10;
    const cols = Math.floor(width / cellSize);
    const rows = Math.floor(height / cellSize);
    
    let grid = [];
    let stepCount = 0;

    function resetSim() {
        stepCount = 0;
        grid = Array.from({ length: cols }, () => 
            Array.from({ length: rows }, () => {
                const rand = Math.random();
                if (rand > 0.95) return 2; // Predator
                if (rand > 0.85) return 1; // Producer
                return 0; // Empty
            })
        );
        updateUI();
        draw();
    }

    function getNeighbors(x, y) {
        let count = { 1: 0, 2: 0 };
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                let nx = (x + i + cols) % cols;
                let ny = (y + j + rows) % rows;
                let val = grid[nx][ny];
                if (val !== 0) count[val]++;
            }
        }
        return count;
    }

    function manualStep() {
        stepCount++;
        let nextGrid = grid.map(arr => [...arr]);

        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                let current = grid[x][y];
                let neighbors = getNeighbors(x, y);

                if (current === 1) { // 生产者逻辑
                    // 若周围掠夺者成群（规模效应），生产者被转化
                    if (neighbors[2] >= 2) {
                        nextGrid[x][y] = 2; 
                    } else if (Math.random() > 0.95 && neighbors[1] < 4) {
                        // 自然生长
                        let tx = (x + Math.floor(Math.random()*3-1) + cols) % cols;
                        let ty = (y + Math.floor(Math.random()*3-1) + rows) % rows;
                        if(grid[tx][ty] === 0) nextGrid[tx][ty] = 1;
                    }
                } 
                else if (current === 2) { // 掠夺者逻辑
                    // 规模效应：掠夺者更倾向于向同类聚集（吸积）
                    if (neighbors[2] < 1 && neighbors[1] === 0) {
                        if (Math.random() > 0.7) nextGrid[x][y] = 0; // 孤立且无资源则消失
                    } else if (neighbors[1] > 0) {
                        // 掠夺扩散
                        let tx = (x + Math.floor(Math.random()*3-1) + cols) % cols;
                        let ty = (y + Math.floor(Math.random()*3-1) + rows) % rows;
                        if(grid[tx][ty] === 1) nextGrid[tx][ty] = 2;
                    }
                }
                else {
                    // 自发产生少量生产者
                    if (Math.random() > 0.998) nextGrid[x][y] = 1;
                }
            }
        }

        grid = nextGrid;
        updateUI();
        draw();
    }

    function updateUI() {
        let predators = 0, producers = 0;
        grid.flat().forEach(v => {
            if(v === 1) producers++;
            if(v === 2) predators++;
        });

        document.getElementById('v-step').innerText = stepCount;
        document.getElementById('v-ratio').innerText = ((predators/(producers+1))*100).toFixed(1) + "%";
        
        // 复杂度指标：模拟从无序到有序的过程
        let phaseDisplay = d3.select("#phase-title");
        if(stepCount < 20) {
            phaseDisplay.text("Tier 1: Atomic Jungle").style("color", "#4caf50");
            document.getElementById('v-h').innerText = "High";
        } else if (stepCount < 60) {
            phaseDisplay.text("Tier 2: Predatory Clusters").style("color", "#ff9800");
            document.getElementById('v-h').innerText = "Medium";
        } else {
            phaseDisplay.text("Tier 3: Leviathan Steady").style("color", "#f44336");
            document.getElementById('v-h').innerText = "Low";
        }
    }

    function draw() {
        ctx.fillStyle = '#0a0a0c';
        ctx.fillRect(0, 0, width, height);
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                if (grid[x][y] === 0) continue;
                ctx.fillStyle = grid[x][y] === 1 ? '#4caf50' : '#f44336';
                ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
            }
        }
    }

    // 初始启动
    resetSim();
</script>
</body>
</html>